package software.leonov.concurrent;

import static java.util.Objects.requireNonNull;

import java.util.List;
import java.util.concurrent.AbstractExecutorService;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.Semaphore;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * A {@code BoundedExecutorService} enforces a limit on the maximum number of tasks that can be submitted the underlying
 * {@link ThreadPoolExecutor} via any of its {@code execute}, {@code submit}, {@code invokeAny}, or {@code invokeAll}
 * methods. Once the maximum number of tasks have been accepted further tasks will block until a previous task finishes
 * executing.
 * <p>
 * Users can use this class to control the concurrency in different sections of their code to avoid overloading a shared
 * global thread pool.
 * <p>
 * <b>Note:</b> This class is not designed to directly restrict the number of threads generated by the underlying
 * {@code ThreadPoolExecutor}. The bounding mechanism focuses solely on limiting the number of tasks accepted for
 * execution.
 * 
 * @author Zhenya Leonov
 */
public final class BoundedExecutorService extends AbstractExecutorService {

    private final ExecutorService exec;
    private final Semaphore       semaphore;
    private final int             ntasks;

    /**
     * Creates a new {@link BoundedExecutorService} which will limit the maximum number of tasks that can be submitted to
     * the underlying {@code ThreadPoolExecutor} via any of its {@code execute}, {@code submit}, {@code invokeAny}, or
     * {@code invokeAll} methods. Once the maximum number of tasks have been submitted further submissions will block until
     * a previous task finishes executing.
     * 
     * @param exec   the underlying executor service
     * @param ntasks the maximum number of tasks allowed to execute concurrently
     */
    public BoundedExecutorService(final ThreadPoolExecutor exec, final int ntasks) {
        requireNonNull(exec, "exec == null");

        final BlockingQueue<?> workQueue       = exec.getQueue();
        final int              maximumPoolSize = exec.getMaximumPoolSize();
        final int              size            = workQueue.size();
        
        if(maximumPoolSize < Integer.MAX_VALUE && workQueue.remainingCapacity() < Integer.MAX_VALUE && workQueue.remainingCapacity() < Integer.MAX_VALUE - size)
            throw new IllegalArgumentException("expected cached thread pool");

        if (ntasks < 1)
            throw new IllegalArgumentException("ntasks < 1");

        this.exec      = exec;
        this.semaphore = new Semaphore(ntasks);
        this.ntasks    = ntasks;
    }

    @Override
    public void execute(final Runnable command) {
        requireNonNull(command, "command == null");

        try {
            semaphore.acquire();
            exec.execute(() -> {
                try {
                    command.run();
                } finally {
                    semaphore.release();
                }
            });
        } catch (final RejectedExecutionException e) {
            semaphore.release();
            throw e;
        } catch (final InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    @Override
    public boolean awaitTermination(final long timeout, final TimeUnit unit) throws InterruptedException {
        requireNonNull(unit, "unit == null");
        return exec.awaitTermination(timeout, unit);
    }

    @Override
    public boolean isShutdown() {
        return exec.isShutdown();
    }

    @Override
    public boolean isTerminated() {
        return exec.isTerminated();
    }

    @Override
    public void shutdown() {
        exec.shutdown();
    }

    @Override
    public List<Runnable> shutdownNow() {
        final List<Runnable> tasks = exec.shutdownNow();
        semaphore.release(tasks.size());
        return tasks;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName() + "[" + exec.toString() + ", bound = " + ntasks + "]";
    }

    /**
     * Returns the underlying {@code ExecutorService}.
     * 
     * @return the underlying {@code ExecutorService}
     */
    public ExecutorService getDelegate() {
        return exec;
    }

}