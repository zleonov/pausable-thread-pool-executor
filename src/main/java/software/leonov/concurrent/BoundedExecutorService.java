package software.leonov.concurrent;

import static java.util.Objects.requireNonNull;

import java.util.List;
import java.util.concurrent.AbstractExecutorService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * A {@code BoundedExecutorService} enforces a limit on the maximum number of tasks that can be submitted the underlying
 * {@code ExecutorService} via any of its {@code execute}, {@code submit}, {@code invokeAny}, or {@code invokeAll}
 * methods. Once the maximum number of tasks have been accepted further tasks will block until a previous task
 * completes.
 * <p>
 * Users can use this class to control the concurrency in different sections of their code to avoid overloading a shared
 * global thread pool.
 * <p>
 * <b>Note:</b> This class is not designed to directly restrict the number of threads generated by the underlying
 * {@code ExecutorService}. The bounding mechanism focuses solely on limiting the number of tasks accepted for
 * execution.
 * <p>
 * While {@code BoundedExecutorService} is agnostic to the underlying {@code ExecutorService} implementation, <b><u>in
 * order for the bounding mechanism to function correctly the underlying executor service MUST be able to accept an
 * unlimited number of tasks for execution.</b></u> Typically this will be accomplished by providing a thread pool with
 * an unbounded work queue, like a standard {@link Executors#newFixedThreadPool(int) fixed thread pool}, or a thread
 * pool that can create an unlimited number of pooled threads, like a standard {@link Executors#newCachedThreadPool()
 * cached thread pool}. Failure to ensure this constraint may result in subtle, rare, but hard to debug errors, like an
 * unexpected {@link RejectedExecutionException}s.
 * 
 * @author Zhenya Leonov
 */
public final class BoundedExecutorService extends AbstractExecutorService {

    private final ExecutorService exec;
    private final Semaphore       semaphore;
    private final int             ntasks;

    /**
     * Creates a new {@link BoundedExecutorService} which will limit on the maximum number of tasks that can be submitted
     * the underlying {@code ExecutorService} via any of its {@code execute}, {@code submit}, {@code invokeAny}, or
     * {@code invokeAll} methods. Once the maximum number of tasks have been submitted further submissions will block until
     * a previous task finishes executing.
     * 
     * @param exec   the underlying executor service
     * @param ntasks the maximum number of tasks allowed to execute concurrently
     */
    public BoundedExecutorService(final ExecutorService exec, final int ntasks) {
        requireNonNull(exec, "exec == null");

        if (ntasks < 1)
            throw new IllegalArgumentException("ntasks < 1");

        this.exec      = exec;
        this.semaphore = new Semaphore(ntasks);
        this.ntasks    = ntasks;
    }

    @Override
    public void execute(final Runnable command) {
        requireNonNull(command, "command == null");

        try {
            semaphore.acquire();
            exec.execute(() -> {
                try {
                    command.run();
                } finally {
                    semaphore.release();
                }
            });
        } catch (final RejectedExecutionException e) {
            semaphore.release();
            throw e;
        } catch (final InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    @Override
    public boolean awaitTermination(final long timeout, final TimeUnit unit) throws InterruptedException {
        requireNonNull(unit, "unit == null");
        return exec.awaitTermination(timeout, unit);
    }

    @Override
    public boolean isShutdown() {
        return exec.isShutdown();
    }

    @Override
    public boolean isTerminated() {
        return exec.isTerminated();
    }

    @Override
    public void shutdown() {
        exec.shutdown();
    }

    @Override
    public List<Runnable> shutdownNow() {
        final List<Runnable> tasks = exec.shutdownNow();
        semaphore.release(tasks.size());
        return tasks;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName() + "[" + exec.toString() + ", bound = " + ntasks + "]";
    }

    /**
     * Returns the underlying {@code ExecutorService}.
     * 
     * @return the underlying {@code ExecutorService}
     */
    public ExecutorService getDelegate() {
        return exec;
    }

}