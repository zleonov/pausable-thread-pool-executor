package software.leonov.concurrent;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * A {@code BoundedExecutorService} enforces a limit on the maximum number of tasks that can be
 * {@link Executor#execute(Runnable) executed} concurrently by another {@code ExecutorService}. Once the maximum number
 * of tasks have been submitted further submissions will block until a previous task finishes executing.
 * <p>
 * Users can use this class to control the concurrency in different sections of their code to avoid overloading a shared
 * global thread pool.
 * <p>
 * <b>Note:</b> A {@code BoundedExecutorService} does not impose a strict limit on number of threads generated by the
 * underlying executor, as this class has no control over the behavior or implementation of the supplied
 * {@code ExecutorService} class. Restricting task submissions alone does not directly affect the number of threads that
 * the underlying executor may create.
 * <p>
 * Consider an executor with an unrestricted thread pool, that has been optimized to initiate task execution immediately
 * upon arrival. When a new task is {@link ExecutorService#submit(Runnable) submitted} or executed, a new thread
 * <i>may</i> be created to handle the incoming task, even after a preceding task's completion, for example if the
 * thread executing the previous task is occupied with post-task cleanup or other internal operations.
 * 
 * @author Zhenya Leonov
 */
public final class BoundedExecutorService extends BoundedExecutor implements ExecutorService {

    public BoundedExecutorService(final ExecutorService exec, final int ntasks) {
        super(exec, ntasks);
    }

    @Override
    public void shutdown() {
        getDelegate().shutdown();
    }

    @Override
    public List<Runnable> shutdownNow() {
        return getDelegate().shutdownNow();
    }

    @Override
    public boolean isShutdown() {
        return getDelegate().isShutdown();
    }

    @Override
    public boolean isTerminated() {
        return getDelegate().isTerminated();
    }

    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return getDelegate().awaitTermination(timeout, unit);
    }

    @Override
    public <T> Future<T> submit(Callable<T> task) {
        return getDelegate().submit(task);
    }

    @Override
    public <T> Future<T> submit(Runnable task, T result) {
        return getDelegate().submit(task, result);
    }

    @Override
    public Future<?> submit(Runnable task) {
        return getDelegate().submit(task);
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        return getDelegate().invokeAll(tasks);
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
        return getDelegate().invokeAll(tasks, timeout, unit);
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
        return getDelegate().invokeAny(tasks);
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        return getDelegate().invokeAny(tasks, timeout, unit);
    }

    /**
     * Returns the underlying {@code ExecutorService}.
     * 
     * @return the underlying {@code ExecutorService}
     */
    @Override
    public ExecutorService getDelegate() {
        return (ExecutorService) super.getDelegate();
    }

}