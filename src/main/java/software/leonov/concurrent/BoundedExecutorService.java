package software.leonov.concurrent;

import static java.util.Objects.requireNonNull;

import java.util.List;
import java.util.concurrent.AbstractExecutorService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.Semaphore;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * A {@code BoundedExecutorService} enforces a limit on the maximum number of tasks that can be submitted the underlying
 * {@code ExecutorService} via any of its {@code execute}, {@code submit}, {@code invokeAny}, or {@code invokeAll}
 * methods. Once the maximum number of tasks have been accepted further tasks will block until a previous task finishes
 * executing.
 * <p>
 * Users can use this class to control the concurrency in different sections of their code to avoid overloading a shared
 * global thread pool.
 * <p>
 * <b>Note:</b> This class is not designed to directly restrict the number of threads generated by the underlying
 * {@code ExecutorService}. The bounding mechanism focuses solely on limiting the number of tasks accepted for
 * execution.
 * <p>
 * <b>Usage considerations:</b><br>
 * While {@code BoundedExecutorService} is agnostic to the underlying {@code ExecutorService} implementation, e.g.
 * {@link Executors#newFixedThreadPool(int) fixed thread pools}, {@link Executors#newCachedThreadPool() cached thread
 * pools}, or custom implementations with varying {@link ThreadPoolExecutor#getQueue() task queue}s, the underlying
 * {@code ExecutorService} should have the capacity to accept more tasks (either by executing them immediately or by
 * placing them on the queue) than the enforced limit.
 * 
 * @author Zhenya Leonov
 */
public final class BoundedExecutorService extends AbstractExecutorService {

    private final ExecutorService exec;
    private final Semaphore       semaphore;
    private final int             ntasks;

    /**
     * Creates a new {@link BoundedExecutorService} which will limit on the maximum number of tasks that can be submitted
     * the underlying {@code ExecutorService} via any of its {@code execute}, {@code submit}, {@code invokeAny}, or
     * {@code invokeAll} methods. Once the maximum number of tasks have been submitted further submissions will block until
     * a previous task finishes executing.
     * 
     * @param exec   the underlying executor service
     * @param ntasks the maximum number of tasks allowed to execute concurrently
     */
    public BoundedExecutorService(final ExecutorService exec, final int ntasks) {
        requireNonNull(exec, "exec == null");

        if (ntasks < 1)
            throw new IllegalArgumentException("ntasks < 1");

        this.exec      = exec;
        this.semaphore = new Semaphore(ntasks);
        this.ntasks    = ntasks;
    }

    @Override
    public void execute(final Runnable command) {
        requireNonNull(command, "command == null");

        try {
            semaphore.acquire();
            exec.execute(() -> {
                try {
                    command.run();
                } finally {
                    semaphore.release();
                }
            });
        } catch (final RejectedExecutionException e) {
            semaphore.release();
            throw e;
        } catch (final InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    @Override
    public boolean awaitTermination(final long timeout, final TimeUnit unit) throws InterruptedException {
        requireNonNull(unit, "unit == null");
        return exec.awaitTermination(timeout, unit);
    }

    @Override
    public boolean isShutdown() {
        return exec.isShutdown();
    }

    @Override
    public boolean isTerminated() {
        return exec.isTerminated();
    }

    @Override
    public void shutdown() {
        exec.shutdown();
    }

    /**
     * Halts the processing of pending tasks but does not attempt to stop actively executing tasks. All pending tasks are
     * drained (removed) from the task queue and returned when this method completes.
     * <p>
     * This method does not wait for actively executing tasks to terminate. Use
     * {@link Execution#awaitTermination(ExecutorService)} or {@link ThreadPoolExecutor#awaitTermination(long, TimeUnit)} to
     * do that.
     * <p>
     * This method is the middle ground between {@link ExecutorService#shutdown()} and
     * {@link ExecutorService#shutdownNow()}:
     * <ul>
     * <li>{@link ExecutorService#shutdown() shutdown()}: all actively executing tasks and pending tasks are allowed to
     * continue, but no new tasks will be accepted</li>
     * <li><b>shutdownFast():</b> all actively executing tasks are allowed to continue, <b>pending tasks are removed</b>,
     * and no new tasks will be accepted</li>
     * <li>{@link ExecutorService#shutdownNow() shutdownNow()}: all actively executing tasks are <u>interrupted</u>, pending
     * tasks are removed, and no new tasks will be accepted</li>
     * </ul>
     * <p>
     * <b>Warning:</b> This method is not supported if the underlying {@code ExecutorService} supplied at construction is
     * not an instance of {@link ThreadPoolExecutor}.
     * 
     * @return the list of pending tasks throws UnsupportedOperationException if the underlying {@code ExecutorService}
     *         supplied at construction is not an instance of {@link ThreadPoolExecutor}
     */
    public List<Runnable> shutdownFast() throws UnsupportedOperationException {
        if (exec instanceof ThreadPoolExecutor)
            return Execution.shutdownFast((ThreadPoolExecutor) exec);
        throw new UnsupportedOperationException("the underlying ExecutorService is not an instance of ThreadPoolExecutor");
    }

    @Override
    public List<Runnable> shutdownNow() {
        final List<Runnable> tasks = exec.shutdownNow();
        semaphore.release(tasks.size());
        return tasks;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName() + "[" + exec.toString() + ", bound = " + ntasks + "]";
    }

    /**
     * Returns the underlying {@code ExecutorService}.
     * 
     * @return the underlying {@code ExecutorService}
     */
    public ExecutorService getDelegate() {
        return exec;
    }

}