package software.leonov.concurrent;

import static java.util.Objects.requireNonNull;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.AbstractExecutorService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.Semaphore;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

/**
 * A {@code BoundedExecutorService} enforces a limit on the maximum number of tasks that can be submitted the underlying
 * {@code ExecutorService} via any of its {@code execute}, {@code submit}, {@code invokeAny}, or {@code invokeAll}
 * methods. Once the maximum number of tasks have been accepted further tasks will block until a previous task
 * completes.
 * <p>
 * Users can use this class to control the concurrency in different sections of their code to avoid overloading a shared
 * global thread pool.
 * <p>
 * In addition this class provides a new {@link #await()} method with novel functionality to wait for submitted tasks to
 * complete execution.
 * <p>
 * <b>Note:</b> This class is not designed to directly restrict the number of threads generated by the underlying
 * {@code ExecutorService}. The bounding mechanism focuses solely on limiting the number of tasks accepted for
 * execution.
 * <p>
 * While {@code BoundedExecutorService} is agnostic to the underlying {@code ExecutorService} implementation, <b><u>in
 * order for the bounding mechanism to function correctly the underlying executor service MUST be able to accept an
 * unlimited number of tasks for execution.</b></u> Typically this will be accomplished by providing a thread pool with
 * an unbounded work queue, like a standard {@link Executors#newFixedThreadPool(int) fixed thread pool}, or a thread
 * pool that can create an unlimited number of pooled threads, like a standard {@link Executors#newCachedThreadPool()
 * cached thread pool}. Failure to ensure this constraint may result in subtle, rare, but hard to debug errors, like
 * unexpected {@link RejectedExecutionException}s.
 * 
 * @author Zhenya Leonov
 */
public final class BoundedExecutorService extends AbstractExecutorService {

    private final ExecutorService exec;
    private final Semaphore       semaphore;
    private final int             ntasks;
    private final Counter         counter = new Counter(0);

    /**
     * Returns a {@link BoundedExecutorService} that executes tasks in a fixed number of threads and blocks callers when at
     * capacity.
     * <p>
     * Unlike a traditional {@link Executors#newFixedThreadPool(int) fixed thread pool} which queues unlimited tasks, a
     * {@link BlockingThreadPoolExecutor} blocks the submitting thread if all pooled threads are busy. The caller remains
     * blocked until a thread becomes available to process the new task. This approach prevents memory exhaustion from
     * unbounded task queues while providing automatic flow control through blocking semantics.
     * 
     * @param nthreads the specified number of threads
     */
    public static BoundedExecutorService newFixedThreadPool(final int nthreads) {
        return new BoundedExecutorService((AbstractExecutorService) Executors.newFixedThreadPool(nthreads), nthreads);
    }

    /**
     * Returns a {@link BoundedExecutorService} that executes tasks in a fixed number of threads and blocks callers when at
     * capacity.
     * <p>
     * Unlike a traditional {@link Executors#newFixedThreadPool(int) fixed thread pool} which queues unlimited tasks, a
     * {@link BlockingThreadPoolExecutor} blocks the submitting thread if all pooled threads are busy. The caller remains
     * blocked until a thread becomes available to process the new task. This approach prevents memory exhaustion from
     * unbounded task queues while providing automatic flow control through blocking semantics.
     * 
     * @param nthreads the specified number of threads
     * @param factory  the thread factory to use when creating new threads
     */
    public static BoundedExecutorService newFixedThreadPool(final int nthreads, final ThreadFactory factory) {
        return new BoundedExecutorService((AbstractExecutorService) Executors.newFixedThreadPool(nthreads, factory), nthreads);
    }

    /**
     * Creates a new {@link BoundedExecutorService} which will limit on the maximum number of tasks that can be submitted
     * the underlying {@code ExecutorService} via any of its {@code execute}, {@code submit}, {@code invokeAny}, or
     * {@code invokeAll} methods. Once the maximum number of tasks have been submitted further submissions will block until
     * a previous task finishes executing.
     * 
     * @param exec   the underlying executor service
     * @param ntasks the maximum number of tasks allowed to execute concurrently
     */
    public BoundedExecutorService(final AbstractExecutorService exec, final int ntasks) {
        requireNonNull(exec, "exec == null");

        if (ntasks < 1)
            throw new IllegalArgumentException("ntasks < 1");

        this.exec      = exec;
        this.semaphore = new Semaphore(ntasks);
        this.ntasks    = ntasks;
    }

    /**
     * Executes the given task in one of the pooled threads. If all threads are busy the caller will block until a thread
     * becomes available.
     * <p>
     * This method does not throw {@link InterruptedException}s. If the calling thread is interrupted while waiting this
     * method will return immediately having the thread's interrupt status set.
     */
    @Override
    public void execute(final Runnable command) {
        requireNonNull(command, "command == null");

        try {
            semaphore.acquire();
            counter.countUp();
            exec.execute(() -> {
                try {
                    command.run();
                } finally {
                    counter.countDown();
                    semaphore.release();
                }
            });
        } catch (final RejectedExecutionException e) {
            counter.countDown();
            semaphore.release();
            throw e;
        } catch (final InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    /**
     * Waits for all currently submitted tasks to complete execution.
     * <p>
     * Provides a blocking mechanism that suspends the calling thread until all tasks that have been submitted to this
     * executor via {@link #execute(Runnable) execute} or its various {@code submit} methods have finished processing. The
     * executor remains fully operational after this method returns.
     * <p>
     * <b>Motivation and Design Rationale</b>
     * <p>
     * Standard {@link ExecutorService} implementations provide several mechanisms for waiting on task completion, but each
     * comes with limitations that make them undesirable for certain use cases:
     * <p>
     * <table border="1" cellpadding="5">
     * <tr>
     * <th>Approach</th>
     * <th>Limitations</th>
     * </tr>
     * <tr>
     * <td>Call {@link Future#get()} on each {@link Future} returned from task submission</td>
     * <td>
     * <ul>
     * <li>Doesn't work with {@link #execute(Runnable)} which does not return a {@code Future}</li>
     * <li>Requires unnecessary managing and storing of individual {@code Future} objects for {@code Runnable} tasks</li>
     * <li>Forces error handling at the point of waiting in case {@code Future.get()} results in an exception</li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td>Submit all tasks at once and wait for completion using {@link ExecutorService#invokeAll(Collection)
     * invokeAll}</td>
     * <td>
     * <ul>
     * <li>Requires all tasks to be available upfront</li>
     * <li>Only works with {@code Callable} tasks but not {@code Runnable} tasks</li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td>{@link ExecutorService#shutdown() Shutdown} executor and wait for all tasks to complete using
     * {@link ExecutorService#awaitTermination(long, TimeUnit) awaitTermination}</td>
     * <td>
     * <ul>
     * <li>Permanently disables the executor, making it unusuable for subsequent execution</li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * </tr>
     * </table>
     * <p>
     * In contrast, this method uses a {@link Counter} to track submitted and completed tasks, allowing users to wait for
     * task completion on any set of tasks, submitted through any method, without shutting down the executor or managing
     * individual {@code Future}s.
     * <p>
     * <b>Warning:</b> It is generally required that all tasks intended for the current batch be submitted <i>before</i>
     * calling {@code await} to ensure correct behavior. Race conditions may occur if some threads are actively submitting
     * tasks while other threads are waiting for tasks to complete.
     *
     * @throws InterruptedException if this thread is interrupted while waiting
     */
    public void await() throws InterruptedException {
        counter.await();
    }

    @Override
    public boolean awaitTermination(final long timeout, final TimeUnit unit) throws InterruptedException {
        requireNonNull(unit, "unit == null");
        return exec.awaitTermination(timeout, unit);
    }

    @Override
    public boolean isShutdown() {
        return exec.isShutdown();
    }

    @Override
    public boolean isTerminated() {
        return exec.isTerminated();
    }

    @Override
    public void shutdown() {
        exec.shutdown();
    }

    @Override
    public List<Runnable> shutdownNow() {
        final List<Runnable> tasks = exec.shutdownNow();
        for (int i = 0; i < tasks.size(); i++) {
            counter.countDown();
            semaphore.release();
        }
        return tasks;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName() + "[" + exec.toString() + ", bound = " + ntasks + "]";
    }

    /**
     * Returns the underlying {@code ExecutorService}.
     * <p>
     * <b>Warning:<b> This method is provided for debugging and testing purposes. If the underlying executor service is
     * modified externally while this class is being used the results are undefined.
     * 
     * @return the underlying {@code ExecutorService}
     */
    public ExecutorService getDelegate() {
        return exec;
    }

}